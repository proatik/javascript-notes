## 4. Functions Deep Dive

### âœ… Function Declarations vs Expressions

#### Function Declaration

- Defined with the `function` keyword at the top level.
- **Hoisted** â†’ can be called before they are defined.

```js
sayHello(); // âœ… Works (hoisting)

function sayHello() {
  console.log("Hello!");
}
```

#### Function Expression

- A function assigned to a variable.
- **Not hoisted** â†’ must be defined before calling.

```js
// greet(); âŒ Error: Cannot access before initialization

const greet = function () {
  console.log("Hi!");
};

greet(); // âœ… Works
```

#### Named Function Expression

- Useful for debugging (name shows in stack traces).

```js
const greet = function greetFn() {
  console.log("Hi!");
};
```

#### Key Differences

| Feature            | Declaration | Expression        |
| ------------------ | ----------- | ----------------- |
| Hoisted            | âœ… Yes      | âŒ No             |
| Readable name      | âœ… Yes      | âœ… Yes (if named) |
| Called before def? | âœ… Yes      | âŒ No             |

### âœ… Arrow Functions

#### Syntax

- Shorter syntax for functions.
- **No `function` keyword**, use `=>`.

```js
const add = (a, b) => a + b;
```

#### Key Features

- **Lexical `this`** â†’ inherits `this` from the enclosing scope.
- Cannot be used as a constructor (`new`).
- No `arguments` object.
- Implicit return if no `{}` braces.

```js
// Implicit return
const square = (x) => x * x;

// Explicit return
const cube = (x) => {
  return x * x * x;
};
```

#### Lexical `this` Example

```js
const obj = {
  value: 10,
  regular() {
    setTimeout(function () {
      console.log(this.value); // âŒ undefined
    }, 100);
  },
  arrow() {
    setTimeout(() => {
      console.log(this.value); // âœ… 10
    }, 100);
  },
};

obj.regular();
obj.arrow();
```

#### When **Not** to Use Arrow Functions

- As constructors.
- As object methods (if you need `this` to refer to the object).
- For dynamic context-bound callbacks (`call`, `apply`, `bind` wonâ€™t work).

### âœ… Default, Rest, and Spread in Functions

#### Default Parameters

- Assign default values if arguments are missing or `undefined`.

```js
function greet(name = "Guest") {
  console.log(`Hello, ${name}`);
}

greet(); // Hello, Guest
greet("Atik"); // Hello, Atik
```

#### Rest Parameters (`...`)

- Collects all remaining arguments into an array.

```js
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}

sum(1, 2, 3); // 6
```

#### Spread in Function Calls

- Expands an array into individual arguments.

```js
const nums = [1, 2, 3];
console.log(Math.max(...nums)); // 3
```

#### Spread in Destructuring Inside Functions

```js
function printUser({ name, ...rest }) {
  console.log(name, rest);
}

printUser({ name: "Atik", age: 27, role: "Admin" });
// Atik { age: 27, role: "Admin" }
```

### âœ… First-class & Higher-order Functions

#### First-class Functions

JavaScript treats functions like **values**:

- Can be assigned to variables
- Passed as arguments
- Returned from other functions

```js
// Assigned to a variable
const sayHi = () => console.log("Hi!");

// Passed as an argument
function greet(fn) {
  fn();
}

// Returned from another function
function createGreeter() {
  return () => console.log("Hello from returned function!");
}

greet(sayHi); // Hi!

const newGreeter = createGreeter();
newGreeter(); // Hello from returned function!
```

#### Higher-order Functions (HOF)

Functions that **take other functions as arguments** or **return a function**.

```js
function multiplier(factor) {
  return function (n) {
    return n * factor;
  };
}

const double = multiplier(2);
console.log(double(5)); // 10
```

#### Common Examples in JS

- `map`, `filter`, `reduce` (built-in array HOFs)
- Event listeners
- Middleware functions

```js
const numbers = [1, 2, 3];
const doubled = numbers.map((n) => n * 2); // [2, 4, 6]
```

### âœ… Callback Functions

#### Definition

A **callback function** is a function **passed as an argument** to another function, to be **executed later** (synchronously or asynchronously).

#### Synchronous Callback

Executed immediately within the calling function.

```js
function processUserInput(callback) {
  const name = "Atik";
  callback(name);
}

processUserInput((name) => console.log(`Hello, ${name}`));
// Hello, Atik
```

#### Asynchronous Callback

Executed later, often after some operation finishes (e.g., timers, network calls).

```js
setTimeout(() => {
  console.log("Executed after 1 second");
}, 1000);
```

#### Why Use Callbacks?

- Event handling
- Delaying execution until a task is complete
- Reusable, flexible function behavior

### âœ… Call, Apply, Bind

#### `call()`

- Invokes a function **immediately**, with a specified `this` and arguments **separately**.

```js
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const user = { name: "Atik" };

greet.call(user, "Hello", "!"); // Hello, Atik!
```

#### `apply()`

- Same as `call()`, but arguments are passed as an **array**.

```js
greet.apply(user, ["Hi", "!!"]); // Hi, Atik!!
```

#### `bind()`

- Returns a **new function** with a fixed `this` and optional preset arguments.
- Does **not** call the function immediately.

```js
const boundGreet = greet.bind(user, "Hey");
boundGreet("?"); // Hey, Atik?
```

#### Quick Comparison

| Method | Calls Immediately? | Args Format | Returns New Function? |
| ------ | ------------------ | ----------- | --------------------- |
| call   | âœ… Yes             | List        | âŒ No                 |
| apply  | âœ… Yes             | Array       | âŒ No                 |
| bind   | âŒ No              | List/Array  | âœ… Yes                |

### âœ… IIFE (Immediately Invoked Function Expressions)

#### Definition

A function that is **defined and executed immediately** after creation.

- Used to create a **private scope** and avoid polluting the global namespace.

#### Syntax

```js
(function () {
  console.log("IIFE executed!");
})();
```

#### Arrow Function IIFE

```js
(() => {
  console.log("Arrow IIFE executed!");
})();
```

#### With Parameters

```js
(function (name) {
  console.log(`Hello, ${name}`);
})("Atik");
```

#### Why Use IIFE?

- Isolate logic
- Prevent variable conflicts
- Execute setup code immediately

### âœ… Recursion

#### Definition

A function that **calls itself** to solve a problem by breaking it into smaller subproblems.

#### Basic Example: Factorial

```js
function factorial(n) {
  if (n <= 1) return 1; // Base case
  return n * factorial(n - 1); // Recursive call
}

factorial(5); // 120
```

#### ðŸ”¹ Key Points

- Must have a **base case** to stop recursion.
- Each recursive call works on a smaller input.
- Can be replaced by loops, but recursion is elegant for tree/graph problems.

#### ðŸ”¹ Recursive Fibonacci (inefficient)

```js
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
```

### âœ… Currying

#### Definition

Transforming a function with multiple arguments into a sequence of functions each taking a single argument.

#### Example

```js
// Original function
function add(a, b) {
  return a + b;
}

console.log(add(5, 3)); // 8

// Curried version
function add(a) {
  return function (b) {
    return a + b;
  };
}

const addFive = add(5);
console.log(addFive(3)); // 8
```

#### Using Arrow Functions

```js
const add = (a) => (b) => a + b;

const addTen = add(10);
console.log(addTen(7)); // 17
```

#### Why Use Currying?

- Creates reusable, configurable functions.
- Useful for partial application of arguments.

### âœ… Memoization

#### Definition

Optimization technique to **cache results** of expensive function calls and return cached results when the same inputs occur again.

#### Basic Example: Fibonacci with Memoization

```js
function fib(n, cache = {}) {
  if (n <= 1) return n;
  if (cache[n]) return cache[n];

  cache[n] = fib(n - 1, cache) + fib(n - 2, cache);
  return cache[n];
}

console.log(fib(40)); // Fast compared to plain recursion
```

#### Why Use Memoization?

- Avoids redundant calculations.
- Improves performance for recursive and heavy computations.

### âœ… Debounce & Throttle

#### Debounce

Delays a function call until after a specified wait time has elapsed since the last call. Useful to limit **rapid-fire events** (e.g., window resizing, input typing).

```js
function debounce(fn, delay) {
  let timeoutId;

  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Usage
window.addEventListener(
  "resize",
  debounce(() => {
    console.log("Resize event handled");
  }, 300)
);
```

#### Throttle

Ensures a function is called at most once every specified time interval. Useful for **regular intervals** in high-frequency events.

```js
function throttle(fn, limit) {
  let inThrottle;

  return function (...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

// Usage
window.addEventListener(
  "scroll",
  throttle(() => {
    console.log("Scroll event handled");
  }, 300)
);
```

#### When to Use

- **Debounce:** Wait for user to stop triggering before acting.
- **Throttle:** Limit action to once every interval regardless of frequency.
