## 3. Objects and Arrays

### ✅ Object Literals & Property Descriptors

#### Object Literal Syntax

```js
const user = {
  name: "Atik",
  age: 27,

  greet() {
    console.log(`Hello, ${this.name}`); // ✅ "Atik"
  },

  sayHi: function () {
    console.log(`Hi, ${this.name}`); // ✅ "Atik"
  },

  shout: () => {
    console.log(`HEY, ${this.name}`); // ❌ "undefined"
  },
};
```

- Keys are always strings (even if written without quotes).
- Shorthand is allowed:

```js
const name = "Atik";
const user = { name }; // same as { name: name }
```

- Methods can be defined without the `function` keyword.

#### Property Descriptors

Use `Object.defineProperty` to control property behavior:

```js
Object.defineProperty(user, "id", {
  value: 101,
  writable: false,
  enumerable: true,
  configurable: false,
});
```

| Attribute      | Meaning                                     |
| -------------- | ------------------------------------------- |
| `value`        | The actual value of the property            |
| `writable`     | If `true`, value can be changed             |
| `enumerable`   | If `true`, shows up in loops like `for..in` |
| `configurable` | If `true`, can delete or reconfigure        |

#### View Descriptors

```js
Object.getOwnPropertyDescriptor(user, "id");
```

Returns an object like:

```js
{
  value: 101,
  writable: false,
  enumerable: true,
  configurable: false
}
```

### ✅ Spread & Rest

#### Spread (`...`)

- Expands elements of an iterable (like arrays/objects) into individual elements.

```js
const nums = [1, 2, 3];
const newNums = [...nums, 4, 5];
// [1, 2, 3, 4, 5]

const user = { name: "Atik", age: 27 };
const clone = { ...user, role: "admin" };
// { name: "Atik", age: 27, role: "admin" }
```

#### Rest (`...`)

- Collects remaining elements into an array or object.
- Used in function parameters or destructuring.

```js
function sum(...args) {
  return args.reduce((a, b) => a + b, 0);
}

sum(1, 2, 3); // 6

const { name, ...rest } = { name: "Atik", age: 27, role: "admin" };
// name = "Atik", rest = { age: 27, role: "admin" }
```

### ✅ Destructuring

#### Object Destructuring

- Extracts properties from objects into variables.

```js
const user = { name: "Atik", age: 27 };

const { name, age } = user;
// name = "Atik", age = 27
```

- You can rename and set defaults:

```js
const { name: fullName = "Unknown", role = "guest" } = user;
// fullName = "Atik", role = "guest"
```

#### Array Destructuring

- Extracts values from arrays into variables.

```js
const numbers = [10, 20, 30];

const [a, b] = numbers;
// a = 10, b = 20
```

- Skipping & rest:

```js
const [first, , third] = numbers;
// first = 10, third = 30

const [head, ...tail] = numbers;
// head = 10, tail = [20, 30]
```

### ✅ Object Methods

#### `Object.keys(obj)`

Returns an array of the object's own enumerable property names.

```js
const user = { name: "Atik", age: 27 };
console.log(Object.keys(user)); // ["name", "age"]
```

#### `Object.values(obj)`

Returns an array of the object's own enumerable property values.

```js
console.log(Object.values(user)); // ["Atik", 27]
```

#### `Object.entries(obj)`

Returns an array of `[key, value]` pairs.

```js
console.log(Object.entries(user));
// [["name", "Atik"], ["age", 27]]
```

#### `Object.fromEntries(entries)`

Converts an array of `[key, value]` pairs into an object.

```js
const entries = [
  ["name", "Atik"],
  ["age", 27],
];
console.log(Object.fromEntries(entries));
// { name: "Atik", age: 27 }
```

#### `Object.assign(target, ...sources)`

Copies properties from one or more source objects to a target object (shallow copy).

```js
const a = { x: 1 };
const b = { y: 2 };
const c = Object.assign({}, a, b);
// { x: 1, y: 2 }
```

#### `Object.hasOwn(obj, prop)`

Returns `true` if the object has the property as its own (not inherited).

```js
console.log(Object.hasOwn(user, "name")); // true
```

#### `Object.freeze(obj)`

Freezes the object – makes it immutable.

```js
const frozen = Object.freeze({ name: "Atik" });
frozen.name = "John"; // ❌ no effect
```

#### `Object.seal(obj)`

Prevents adding or removing properties, but allows editing existing ones.

```js
const sealed = Object.seal({ age: 27 });
sealed.age = 28; // ✅
delete sealed.age; // ❌
```

#### `Object.is(a, b)`

Compares two values like `===`, but treats `NaN === NaN` as `true`.

```js
Object.is(NaN, NaN); // true
Object.is(0, -0); // false
```

#### `Object.getOwnPropertyDescriptors(obj)`

Returns all property descriptors (including non-enumerable ones).

```js
console.log(Object.getOwnPropertyDescriptors({ a: 1 }));
```

#### `Object.getPrototypeOf(obj)`

Returns the prototype of the object.

```js
const proto = Object.getPrototypeOf({});
console.log(proto === Object.prototype); // true
```

#### `Object.setPrototypeOf(obj, prototype)`

Sets the prototype of the object.

```js
Object.setPrototypeOf(obj, null);
```

#### `Object.defineProperty(obj, prop, descriptor)`

Defines or modifies a property with control over enumerability, writability, etc.

```js
const user = {};
Object.defineProperty(user, "id", {
  value: 123,
  writable: false,
});
```

#### `Object.defineProperties(obj, descriptors)`

Defines multiple properties at once.

```js
Object.defineProperties(user, {
  name: { value: "Atik" },
  age: { value: 27 },
});
```

### ✅ Array Methods

### Iteration Methods

#### `forEach(callback)`

Executes a function for each element. Doesn't return anything.

```js
[1, 2, 3].forEach((num) => console.log(num));
```

#### `map(callback)`

Returns a new array by applying the function to each element.

```js
const doubled = [1, 2, 3].map((n) => n * 2); // [2, 4, 6]
```

#### `filter(callback)`

Returns a new array with elements that pass the test.

```js
const evens = [1, 2, 3, 4].filter((n) => n % 2 === 0); // [2, 4]
```

#### `reduce(callback, initialValue)`

Reduces the array to a single value.

```js
const sum = [1, 2, 3].reduce((acc, n) => acc + n, 0); // 6
```

#### `reduceRight(callback, initialValue)`

Like `reduce`, but processes from right to left.

```js
["a", "b", "c"].reduceRight((acc, ch) => acc + ch); // "cba"
```

#### `some(callback)`

Returns `true` if _any_ element passes the test.

```js
[1, 2, 3].some((n) => n > 2); // true
```

#### `every(callback)`

Returns `true` if _all_ elements pass the test.

```js
[2, 4, 6].every((n) => n % 2 === 0); // true
```

#### `find(callback)`

Returns the _first_ element that passes the test.

```js
[1, 2, 3].find((n) => n > 1); // 2
```

#### `findIndex(callback)`

Returns the _index_ of the first matching element.

```js
[1, 2, 3].findIndex((n) => n === 2); // 1
```

#### `flat(depth)`

Flattens nested arrays up to `depth` level (default is 1).

```js
[1, [2, [3]]].flat(); // [1, 2, [3]]
[1, [2, [3]]].flat(2); // [1, 2, 3]
```

#### `flatMap(callback)`

Maps each element and flattens the result by one level.

```js
[1, 2, 3].flatMap((n) => [n, n * 2]); // [1, 2, 2, 4, 3, 6]
```

### Searching & Indexing

#### `indexOf(value)`

Returns index of value, or -1 if not found.

```js
[1, 2, 3].indexOf(2); // 1
```

#### `lastIndexOf(value)`

Finds the last occurrence.

```js
[1, 2, 3, 2].lastIndexOf(2); // 3
```

#### `includes(value)`

Returns `true` if the value exists in the array.

```js
[1, 2, 3].includes(2); // true
```

### Modifying Arrays (Mutating)

#### `push(...items)`

Adds to end, returns new length.

```js
const a = [1];
a.push(2); // [1, 2]
```

#### `pop()`

Removes and returns the last item.

```js
a.pop(); // returns 2
```

#### `unshift(...items)`

Adds to front.

```js
a.unshift(0); // [0, 1]
```

#### `shift()`

Removes and returns first item.

```js
a.shift(); // returns 0
```

#### `splice(start, deleteCount, ...items)`

Removes and/or inserts elements.

```js
const arr = [1, 2, 3];
arr.splice(1, 1, "a"); // [1, "a", 3]
```

#### `sort(compareFn)`

Sorts the array in place (mutates).

```js
[3, 1, 2].sort(); // [1, 2, 3]
["a", "c", "b"].sort(); // ["a", "b", "c"]
```

Custom sort:

```js
[5, 12, 3].sort((a, b) => a - b); // ascending
```

#### `reverse()`

Reverses the array in-place.

```js
[1, 2, 3].reverse(); // [3, 2, 1]
```

#### `fill(value, start?, end?)`

Fills elements from `start` to `end` with `value`.

```js
[1, 2, 3].fill(0); // [0, 0, 0]
```

#### `copyWithin(target, start, end)`

Copies a slice to another position within the array.

```js
[1, 2, 3, 4].copyWithin(1, 2); // [1, 3, 4, 4]
```

### Non-Mutating (Returns New Array)

#### `slice(start, end)`

Returns a shallow copy of a portion.

```js
[1, 2, 3].slice(1); // [2, 3]
```

#### `concat(...arrays)`

Joins arrays or values to form a new one.

```js
[1].concat([2, 3]); // [1, 2, 3]
```

#### `join(separator)`

Joins elements into a string.

```js
["a", "b", "c"].join("-"); // "a-b-c"
```

#### `toReversed()` _(ES2023)_

Returns a reversed copy.

```js
[1, 2, 3].toReversed(); // [3, 2, 1]
```

#### `toSorted()` _(ES2023)_

Returns a sorted copy.

```js
[3, 2, 1].toSorted(); // [1, 2, 3]
```

#### `toSpliced(start, deleteCount, ...items)` _(ES2023)_

Returns a modified copy, like `splice`.

```js
[1, 2, 3].toSpliced(1, 1, "a"); // [1, "a", 3]
```
