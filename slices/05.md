## 5. Asynchronous JavaScript

### âœ… Callbacks

#### Definition

A **callback** is a function passed as an argument to another function, to be executed later (after some operation completes).

#### Example (Original approach)

```js
function fetchData(callback) {
  setTimeout(() => {
    const data = { user: "Atik" };
    callback(data);
  }, 1000);
}

fetchData(function (result) {
  console.log("Data received:", result);
});
```

#### Problems with Callbacks

- **Callback Hell** â€“ deeply nested callbacks make code hard to read & maintain.
- Error handling can become messy.
- Inversion of control â€“ execution depends on the other function.

#### Callback Hell Example

```js
getUser(1, function (user) {
  getOrders(user.id, function (orders) {
    getOrderDetails(orders[0].id, function (details) {
      console.log(details);
    });
  });
});
```

#### Solution

- Use **Promises** or **async/await** to make code cleaner and more maintainable.

### âœ… Promises

#### Definition

A **Promise** is an object that represents the eventual completion (or failure) of an asynchronous operation.

It has 3 states:

1. **pending** â†’ initial state, neither fulfilled nor rejected.
2. **fulfilled** â†’ operation completed successfully.
3. **rejected** â†’ operation failed.

#### Creating a Promise

```js
const myPromise = new Promise((resolve, reject) => {
  const success = true;

  if (success) {
    resolve("Operation successful!");
  } else {
    reject("Something went wrong.");
  }
});

myPromise
  .then((result) => console.log(result))
  .catch((error) => console.error(error));
```

#### Callback â†’ Promise Example

(Refactoring the nested callbacks from before)

**Before (callback hell)**

```js
getUser(1, function (user) {
  getOrders(user.id, function (orders) {
    getOrderDetails(orders[0].id, function (details) {
      console.log(details);
    });
  });
});
```

**After (Promises)**

```js
function getUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id, name: "Atik" }), 500);
  });
}

function getOrders(userId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve([{ id: 101, item: "Book" }]), 500);
  });
}

function getOrderDetails(orderId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id: orderId, price: 500 }), 500);
  });
}

// Promise chain
getUser(1)
  .then((user) => getOrders(user.id))
  .then((orders) => getOrderDetails(orders[0].id))
  .then((details) => console.log(details))
  .catch((err) => console.error(err));
```

#### Advantages Over Callbacks

- Avoids **callback hell** with chaining.
- Built-in error handling with `.catch()`.
- Can be easily combined with `Promise.all` / `Promise.race`.

Alright â€” weâ€™ll take the same example from the Promises section and then improve it with **`async`/`await`** for readability.

### âœ… `async` / `await`

#### Definition

- **`async`**: Declares a function that returns a Promise.
- **`await`**: Pauses the execution inside an `async` function until the Promise resolves or rejects.

**Before (promises)**

```js
function getUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id, name: "Atik" }), 500);
  });
}

function getOrders(userId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve([{ id: 101, item: "Book" }]), 500);
  });
}

function getOrderDetails(orderId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id: orderId, price: 500 }), 500);
  });
}

// Promise chain
getUser(1)
  .then((user) => getOrders(user.id))
  .then((orders) => getOrderDetails(orders[0].id))
  .then((details) => console.log(details))
  .catch((err) => console.error(err));
```

**After (async / await)**

```js
function getUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id, name: "Atik" }), 500);
  });
}

function getOrders(userId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve([{ id: 101, item: "Book" }]), 500);
  });
}

function getOrderDetails(orderId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id: orderId, price: 500 }), 500);
  });
}

async function showOrderDetails() {
  try {
    const user = await getUser(1);
    const orders = await getOrders(user.id);
    const details = await getOrderDetails(orders[0].id);
    console.log(details);
  } catch (err) {
    console.error(err);
  }
}

showOrderDetails();
```

### Why Itâ€™s Better

- Looks like synchronous code â€” easier to read.
- Avoids **callback hell** and excessive `.then()` chaining.
- Error handling is straightforward with `try...catch`.

### âœ… Event Loop

#### What is the Event Loop?

The event loop is a process that keeps JavaScript running smoothly by handling synchronous tasks without stopping your code. It watches the call stack and task queues, making sure callbacks run at the right time so the app doesnâ€™t freeze.

#### Core Parts:

- **Call Stack**: Runs your code (functions).
- **Web APIs**: Browser features like timers, DOM events, fetch.
- **Callback Queue (Macrotasks)**: Holds callbacks like `setTimeout`.
- **Microtask Queue**: Holds promise callbacks and `queueMicrotask`.
- **Event Loop**: Moves tasks from queues to the call stack when empty.

#### Execution Flow

1. JavaScript executes **synchronous code** on the call stack.
2. Async events (timers, network) trigger callbacks that go to either:

   - **Microtask queue** (higher priority)
   - **Macrotask queue** (lower priority)

3. After the call stack is empty:

   - The event loop executes **all microtasks** in the microtask queue **before** any macrotask.
   - Then executes **one macrotask** from the macrotask queue.

4. This cycle repeats continuously.

### âœ… Fetch API & AbortController

#### Fetch API

- Modern way to make network requests (replaces `XMLHttpRequest`).
- Returns a **Promise** that resolves to the response object.

```js
fetch("https://api.example.com/data")
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((err) => console.error("Fetch error:", err));
```

#### Handling JSON

- Use `.json()` method on response to parse JSON data.
- Remember `.json()` returns a Promise.

```js
fetch(url)
  .then((res) => res.json())
  .then((json) => console.log(json));
```

#### Error Handling

- Check `response.ok` to handle HTTP errors.

```js
fetch(url)
  .then((res) => {
    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
    return res.json();
  })
  .then((data) => console.log(data))
  .catch((err) => console.error(err));
```

#### AbortController (Cancel Fetch)

- Allows aborting fetch requests (e.g., on timeout or user cancel).

```js
const controller = new AbortController();
const signal = controller.signal;

fetch(url, { signal })
  .then((res) => res.json())
  .then((data) => console.log(data))
  .catch((err) => {
    if (err.name === "AbortError") {
      console.log("Fetch aborted");
    } else {
      console.error("Fetch error:", err);
    }
  });

// Abort fetch after 2 seconds
setTimeout(() => controller.abort(), 2000);
```

### âœ… Timers & Scheduling

#### `setTimeout`

- Executes a function **once** after a specified delay (in milliseconds).

```js
setTimeout(() => {
  console.log("Executed after 1 second");
}, 1000);
```

#### `setInterval`

- Executes a function **repeatedly** at specified intervals.

```js
const intervalId = setInterval(() => {
  console.log("Executed every 2 seconds");
}, 2000);
```

#### Clearing Timers

- Use `clearTimeout` to cancel a scheduled `setTimeout`.
- Use `clearInterval` to stop a repeating `setInterval`.

```js
const timeoutId = setTimeout(() => {
  console.log("This will not run");
}, 3000);

clearTimeout(timeoutId);

clearInterval(intervalId);
```

#### Zero-delay Timeout (`setTimeout(..., 0)`)

- Schedules a callback to run **after the current call stack is cleared** (macrotask).
- Useful for deferring execution but not immediately.

```js
console.log("Start");
setTimeout(() => console.log("Inside timeout"), 0);
console.log("End");
```

Output:

```
Start
End
Inside timeout
```

### âœ… Microtasks & Macrotasks

#### What Are Macrotasks?

- Tasks scheduled to run after the current execution completes.
- Examples:

  - `setTimeout`
  - `setInterval`
  - DOM events (click, scroll)
  - Network events

#### What Are Microtasks?

- Tasks scheduled to run **immediately after the current code**, before any macrotask.
- Examples:

  - Promise `.then` / `.catch` callbacks
  - `queueMicrotask`
  - MutationObserver callbacks

#### Execution Order Summary

| Step                                | Description                         |
| ----------------------------------- | ----------------------------------- |
| 1. Call stack runs synchronous code | Your main code executes             |
| 2. Run all microtasks in queue      | Promise handlers and microtasks run |
| 3. Run one macrotask from queue     | Timers, events, etc. execute next   |
| 4. Repeat the cycle                 | Continuously loops                  |

#### Example

```js
console.log("start");

setTimeout(() => console.log("macrotask"), 0);

Promise.resolve().then(() => console.log("microtask"));

console.log("end");
```

**Output:**

```
start
end
microtask
macrotask
```

Absolutely! Hereâ€™s a polished version of **Concurrency Patterns** with a bit more context for easier understanding and quick revision:

### âœ… Concurrency Patterns

When working with multiple asynchronous operations, you often need ways to **coordinate and combine promises** efficiently. JavaScript provides several built-in patterns for this.

#### ðŸ”¹ Promise.all

- Waits for **all promises to resolve**.
- If **any promise rejects**, the entire `Promise.all` rejects immediately.
- Useful when you need **all results together** before proceeding.

```js
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);

Promise.all([p1, p2])
  .then((results) => console.log(results)) // [1, 2]
  .catch((err) => console.error(err));
```

#### ðŸ”¹ Promise.race

- Resolves or rejects as soon as **any promise** resolves or rejects.
- Useful for **timeout or first-response scenarios**.

```js
const p1 = new Promise((resolve) => setTimeout(() => resolve("First"), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve("Second"), 2000));

Promise.race([p1, p2])
  .then((result) => console.log(result)) // 'First'
  .catch((err) => console.error(err));
```

#### ðŸ”¹ Promise.allSettled

- Waits for **all promises to settle** (fulfilled or rejected).
- Returns an array describing the outcome of each promise.
- Useful when you want **all results regardless of errors**.

```js
const p1 = Promise.resolve(1);
const p2 = Promise.reject("Error");

Promise.allSettled([p1, p2]).then((results) => console.log(results));
/* Output:
[
  { status: 'fulfilled', value: 1 },
  { status: 'rejected', reason: 'Error' }
]
*/
```

#### Promise.any

- Resolves as soon as **any promise is fulfilled**.
- Rejects only if **all promises reject**.
- Useful when you only need **the first successful result**.

```js
const p1 = Promise.reject("Error1");
const p2 = Promise.resolve("Success");

Promise.any([p1, p2])
  .then((result) => console.log(result)) // 'Success'
  .catch((err) => console.error(err));
```

ðŸ’¡ **Takeaway:**
These concurrency patterns allow you to **handle multiple async tasks efficiently** â€” whether you need all results, the first result, or just to know when everything settles.
