## 7. Advanced Objects & Prototypes

### ✅ Prototype

A prototype is an object from which other objects can inherit properties and methods.

### ✅ Prototypal Inheritance

Prototypal inheritance is the mechanism that allows objects to share behavior through the prototype chain.

- Objects inherit directly from other objects (prototype chain).
- Each object has an internal link (`[[Prototype]]`) pointing to another object.

```js
const parent = { greet: () => console.log("Hello") };

const child = Object.create(parent);

child.greet(); // Hello (inherited from parent)
```

### ✅ Prototype Chain (Lookup)

In JavaScript, every object has an internal link to a prototype object. If a property or method is not found on the object itself, JavaScript looks for it on its prototype, and continues up the chain until it’s found or reaches null. This is known as the prototype chain.

- Property/method lookup goes upward until `null`.
- If not found → returns `undefined`.

```js
console.log(child.toString);
// found in Object.prototype (top of chain)
```

### ✅ `Object.create`

- Creates a new object with given prototype.

```js
const animal = { type: "mammal" };

const dog = Object.create(animal);

dog.bark = () => console.log("Woof!");

console.log(dog.type); // mammal (inherited)
```

### ✅ Constructor Functions & `new`

- Functions can be used as object templates with `new`.
- `new` creates a new object, sets prototype, runs constructor.

```js
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function () {
  console.log("Hi, I'm " + this.name);
};

const p1 = new Person("Atik");

p1.sayHi(); // Hi, I'm Atik
```

### ✅ Classes & Inheritance (`extends`, `super`)

- ES6 syntactic sugar over prototypal inheritance.

```js
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a sound`);
  }
}

class Dog extends Animal {
  speak() {
    super.speak();
    console.log(`${this.name} barks`);
  }
}

const animal = new Animal("Rex");

animal.speak(); // Rex makes a sound

const dog = new Dog("Noah");

dog.speak(); // Noah barks
```

### ✅ ES6 Class Features

- **Static methods:** Called on class, not instance.
- **Private fields (#):** Encapsulation.
- **Getters/Setters:** Control property access.

```js
class Counter {
  #count = 0;

  get value() {
    return this.#count;
  }

  increment() {
    this.#count++;
  }

  static description() {
    return "Counter class";
  }
}
```

### ✅ Method Overriding & Polymorphism

- Subclass replaces parent’s method.
- Polymorphism = different forms of same interface.

```js
class Shape {
  area() {
    return 0;
  }
}

class Circle extends Shape {
  constructor(r) {
    super();
    this.r = r;
  }

  area() {
    return Math.PI * this.r ** 2;
  }
}
```

### ✅ `instanceof`, `typeof`

- `instanceof`: Checks prototype chain.
- `typeof`: Checks primitive type.

```js
[] instanceof Array; // true

[] instanceof Object; // true

typeof []; // "object"
```

### ✅ `hasOwnProperty` vs `in`

- `obj.hasOwnProperty(prop)` → only own properties.
- `"prop" in obj` → own + inherited.

```js
const obj = { a: 1 };

"a" in obj; // true

obj.hasOwnProperty("a"); // true

"toString" in obj; // true

obj.hasOwnProperty("toString"); // false
```

### ✅ `Object.getPrototypeOf` / `Object.setPrototypeOf`

- Get/set prototype manually.

```js
const obj = {};

console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

Object.setPrototypeOf(obj, null);

console.log(Object.getPrototypeOf(obj)); // null
```

### ✅ Mixins & Composition

- Combine behaviors without deep inheritance.

```js
const canEat = { eat: () => console.log("Eating") };

const canWalk = { walk: () => console.log("Walking") };

const person = Object.assign({}, canEat, canWalk);

person.walk(); // Walking
```

### ✅ Class-based vs Prototype-based

- **Class-based (Java, C#):** Blueprint defines structure.
- **Prototype-based (JS):** Objects inherit from objects.
- JS `class` is syntactic sugar over prototypes.
