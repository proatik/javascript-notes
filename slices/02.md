## 2. Scoping and Execution

### ✅ Function Scope vs Block Scope

| Feature    | `var`                       | `let` / `const`            |
| ---------- | --------------------------- | -------------------------- |
| Scope Type | Function Scope              | Block Scope (`{}`)         |
| Use Case   | Visible throughout function | Confined to block/loop/etc |

```js
function test() {
  if (true) {
    var a = 1;
    let b = 2;
    const c = 3;
  }
  console.log(a); // ✅ 1
  console.log(b); // ❌ ReferenceError
  console.log(c); // ❌ ReferenceError
}
```

### ✅ Hoisting

Hoisting is JavaScript’s default behavior of allocating memory for variables and functions during the compile phase, before any code is executed. In this process, declarations are moved to the top of their containing scope (global or function), making them accessible before their actual line in the code.

- `var` is hoisted and initialized with `undefined`
- `let` / `const` are hoisted but **not initialized** (TDZ)
- Function declarations are fully hoisted

### Temporal Dead Zone

The **Temporal Dead Zone** is the time between:

- The start of the scope (when the variable is hoisted), and
- The actual line where the variable is declared.

During this period, accessing the variable results in a **ReferenceError**, because although it's hoisted, it hasn't been initialized yet.

```js
console.log(a); // undefined (hoisted with var)
var a = 5;

console.log(b); // ❌ ReferenceError (TDZ: b is hoisted but uninitialized)
let b = 10;

foo(); // ✅ works (function declaration is hoisted)
function foo() {
  console.log("Hello");
}
```

### ✅ Lexical Scope

- Lexical scope means **a function’s scope is determined by where it’s written**, not how it’s called.
- Inner functions can access variables from their outer (parent) scopes.

```js
function outer() {
  let x = 42;
  function inner() {
    console.log(x); // ✅ 42 (lexically scoped)
  }
  inner();
}
outer();
```

### ✅ Closures

- A closure is a function that **remembers** variables from its outer lexical scope, even when called outside that scope

```js
function makeCounter() {
  let count = 0;
  return function () {
    return ++count;
  };
}

const counter = makeCounter();
counter(); // 1
counter(); // 2
```

### ✅ `this` Keyword

- `this` refers to **the object that is calling the function**.
- Its value is determined at **call-time**, not where the function is written.
- Arrow functions don’t have their own `this` — they **inherit** it from the **lexical (outer) scope**.

```js
function regular() {
  console.log(this); // depends on how the function is called
}

const arrow = () => {
  console.log(this); // inherits `this` from surrounding scope
};
```

#### Common `this` Behavior:

| Context              | `this` refers to             |
| -------------------- | ---------------------------- |
| Global scope         | `window` (in browsers)       |
| Object method        | The object itself            |
| Constructor function | The newly created instance   |
| Arrow function       | Lexical `this` (from parent) |

#### Example:

```js
const obj = {
  name: "JS",
  regular() {
    console.log(this.name); // 'JS'
  },
  arrow: () => {
    console.log(this.name); // undefined (from global or outer scope)
  },
};
obj.regular();
obj.arrow();
```

### ✅ Strict Mode

- Enables stricter parsing and error handling
- Disallows: undeclared variables, duplicate param names, silent fails

```js
"use strict";

x = 5; // ❌ ReferenceError (must declare)
```
